<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Professional Morse Code Decoder with QRZ Integration</title>
  <style>
    :root {
      --primary-color: #1a73e8;
      --secondary-color: #34a853;
      --error-color: #ea4335;
      --warning-color: #fbbc04;
      --background-color: #f8f9fa;
      --card-color: #ffffff;
      --text-primary: #202124;
      --text-secondary: #5f6368;
      --callsign-color: #0066cc;
      --qrz-bubble-color: #fff3cd;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--background-color);
      color: var(--text-primary);
      margin: 0;
      padding: 20px;
      line-height: 1.6;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
    }

    h1 {
      color: var(--primary-color);
      margin-bottom: 10px;
    }

    .card {
      background-color: var(--card-color);
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 20px;
    }

    .card-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 15px;
      color: var(--primary-color);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 20px;
    }

    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.2s;
    }

    button:hover {
      background-color: #0d62d0;
    }

    button:disabled {
      background-color: #a9c8f5;
      cursor: not-allowed;
    }

    button.stop {
      background-color: var(--error-color);
    }

    button.stop:hover {
      background-color: #d32f2f;
    }

    .visualizers {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }

    canvas {
      width: 100%;
      background-color: #f0f0f0;
      border-radius: 4px;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }

    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .on {
      background-color: var(--secondary-color);
    }

    .off {
      background-color: var(--text-secondary);
    }

    .settings {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .setting-item {
      margin-bottom: 15px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    input[type="range"] {
      width: 100%;
    }

    input[type="text"], input[type="password"] {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    .value-display {
      font-size: 14px;
      color: var(--text-secondary);
      text-align: right;
      margin-top: 5px;
    }

    .output-container {
      background-color: #f0f0f0;
      border-radius: 4px;
      padding: 15px;
      min-height: 100px;
      margin-bottom: 20px;
      font-family: monospace;
      white-space: pre-wrap;
      overflow-y: auto;
      max-height: 300px;
      transition: background-color 0.1s;
      position: relative;
    }
    
    .flash {
      background-color: #e0f0ff;
    }

    .morse-buffer {
      font-family: monospace;
      font-size: 16px;
      margin-top: 10px;
      color: var(--text-secondary);
    }

    .signal-bar {
      height: 20px;
      background-color: #e0e0e0;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 10px;
    }

    .signal-level {
      height: 100%;
      background-color: var(--primary-color);
      width: 0%;
      transition: width 0.1s;
    }

    .threshold-marker {
      position: relative;
      height: 0;
    }

    .threshold-marker::before {
      content: '';
      position: absolute;
      top: -20px;
      height: 20px;
      width: 2px;
      background-color: var(--error-color);
    }

    .indicators {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
    }

    .indicator {
      flex: 1;
      text-align: center;
      padding: 10px;
      background-color: #f0f0f0;
      border-radius: 4px;
    }

    .indicator-value {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .indicator-label {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .status-bar {
      background-color: var(--primary-color);
      color: white;
      padding: 10px 15px;
      border-radius: 4px;
      margin-top: 20px;
      display: flex;
      justify-content: space-between;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .visualizers {
        grid-template-columns: 1fr;
      }
      
      .settings {
        grid-template-columns: 1fr;
      }
    }

    .tone-indicator {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      margin-left: 10px;
      background-color: grey;
    }

    .tone-match {
      background-color: var(--secondary-color);
    }

    /* QRZ Integration Styles */
    .qrz-settings {
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 15px;
      margin-bottom: 15px;
      background-color: #f9f9f9;
    }

    .qrz-settings h4 {
      margin-top: 0;
      margin-bottom: 15px;
      color: var(--primary-color);
    }

    .detected-callsign {
      background-color: var(--callsign-color);
      color: white;
      padding: 2px 6px;
      border-radius: 3px;
      cursor: pointer;
      position: relative;
      display: inline-block;
      margin: 0 2px;
    }

    .detected-callsign:hover {
      background-color: #0052a3;
    }

    .qrz-bubble {
      position: fixed;
      background-color: var(--qrz-bubble-color);
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      min-width: 300px;
      max-width: 400px;
      font-size: 12px;
      line-height: 1.4;
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
    }

    .qrz-bubble.show {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .qrz-bubble h5 {
      margin: 0 0 8px 0;
      color: var(--primary-color);
      font-size: 14px;
      font-weight: 600;
    }

    .qrz-bubble .qrz-field {
      margin-bottom: 6px;
    }

    .qrz-bubble .qrz-label {
      font-weight: 600;
      color: var(--text-secondary);
    }

    .qrz-bubble .qrz-loading {
      text-align: center;
      color: var(--text-secondary);
      font-style: italic;
    }

    .qrz-bubble .qrz-error {
      color: var(--error-color);
      font-style: italic;
    }

    .callsign-log {
      margin-top: 15px;
      padding: 10px;
      background-color: #f0f0f0;
      border-radius: 4px;
      max-height: 200px;
      overflow-y: auto;
    }

    .callsign-log h4 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: var(--primary-color);
    }

    .callsign-entry {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 0;
      border-bottom: 1px solid #ddd;
      font-size: 12px;
    }

    .callsign-entry:last-child {
      border-bottom: none;
    }

    .callsign-entry .callsign {
      font-weight: 600;
      color: var(--callsign-color);
    }

    .callsign-entry .timestamp {
      color: var(--text-secondary);
      font-size: 11px;
    }

    .qrz-status {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
      font-size: 12px;
    }

    .qrz-status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: var(--text-secondary);
    }

    .qrz-status-dot.connected {
      background-color: var(--secondary-color);
    }

    .connecting-line {
      position: fixed;
      height: 2px;
      background-color: var(--callsign-color);
      opacity: 0.7;
      z-index: 999;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Professional Morse Code Decoder with QRZ Integration</h1>
      <p>Decode Morse code from microphone input with adaptive speed (12-40 WPM), frequency (500-900 Hz), and automatic callsign lookup</p>
    </header>

    <div class="card">
      <div class="card-title">
        <span>Control Panel</span>
        <div class="status-dot off" id="statusDot"></div>
        <span style="margin-left: auto; font-size: 12px; color: var(--text-secondary);">Auto-adaptive decoder</span>
      </div>
      
      <div class="controls">
        <button id="startBtn">Start Decoding</button>
        <button id="stopBtn" class="stop" disabled>Stop</button>
        <button id="clearBtn">Clear Output</button>
      </div>
      
      <div class="settings">
        <div class="setting-group">
          <div class="setting-item">
            <label for="toneFrequency">Manual Target Frequency (Hz) <span style="font-size: 11px; color: var(--text-secondary);">(Auto-adjusts during decoding)</span></label>
            <input type="range" id="toneFrequency" min="500" max="900" step="10" value="700">
            <div class="value-display"><span id="toneFrequencyValue">700</span> Hz</div>
          </div>
          
          <div class="setting-item">
            <label for="wpmRange">Manual Speed (WPM) <span style="font-size: 11px; color: var(--text-secondary);">(Auto-adjusts during decoding)</span></label>
            <input type="range" id="wpmRange" min="12" max="40" step="1" value="20">
            <div class="value-display"><span id="wpmValue">20</span> WPM</div>
          </div>
        </div>
        
        <div class="setting-group">
          <div class="setting-item">
            <label for="thresholdLevel">Threshold Level <span style="font-size: 11px; color: var(--text-secondary);">(Recommended: 0.10)</span></label>
            <input type="range" id="thresholdLevel" min="0.05" max="0.5" step="0.01" value="0.10">
            <div class="value-display"><span id="thresholdValue">0.10</span></div>
          </div>
          
          <div class="setting-item">
            <label for="noiseReduction">Noise Reduction <span style="font-size: 11px; color: var(--text-secondary);">(Higher for noisy signals)</span></label>
            <input type="range" id="noiseReduction" min="0" max="10" step="1" value="5">
            <div class="value-display"><span id="noiseReductionValue">5</span></div>
          </div>
        </div>
      </div>

      <!-- QRZ Settings -->
      <div class="qrz-settings">
        <h4>QRZ.com Integration</h4>
        <div class="qrz-status">
          <div class="qrz-status-dot" id="qrzStatusDot"></div>
          <span id="qrzStatusText">QRZ lookup disabled</span>
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
          <div class="setting-item">
            <label for="qrzUsername">QRZ Username:</label>
            <input type="text" id="qrzUsername" placeholder="Your QRZ username">
          </div>
          
          <div class="setting-item">
            <label for="qrzPassword">QRZ Password:</label>
            <input type="password" id="qrzPassword" placeholder="Your QRZ password">
          </div>
        </div>
        
        <div style="display: flex; gap: 15px; align-items: center; margin-bottom: 15px;">
          <button id="qrzTestBtn">Test QRZ Connection</button>
          
          <div style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="autoCallsignDetection" style="width: auto;">
            <label for="autoCallsignDetection" style="margin: 0; font-size: 14px;">Auto-detect callsigns</label>
          </div>
        </div>
        
        <div style="margin-top: 10px; font-size: 11px; color: var(--text-secondary);">
          <strong>Note:</strong> QRZ XML subscription required for full functionality. Credentials are only used for API access and stored locally.
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-title">Decoder Output</div>
      
      <div class="morse-buffer" id="morseBuffer"></div>
      <div class="output-container" id="outputText"></div>
      
      <div class="callsign-log" id="callsignLog">
        <h4>Detected Callsigns</h4>
        <div id="callsignEntries">No callsigns detected yet...</div>
      </div>
    </div>

    <div class="card">
      <div class="card-title">Signal Visualizers</div>
      
      <div class="indicators">
        <div class="indicator">
          <div class="indicator-value" id="currentTone">0</div>
          <div class="indicator-label">Current Tone (Hz)</div>
        </div>
        
        <div class="indicator">
          <div class="indicator-value" id="currentWpm">0</div>
          <div class="indicator-label">Detected WPM</div>
        </div>
        
        <div class="indicator">
          <div class="indicator-value" id="snr">0</div>
          <div class="indicator-label">Signal/Noise Ratio</div>
        </div>
        
        <div class="indicator">
          <div class="indicator-value" id="confidence">0%</div>
          <div class="indicator-label">Decoding Confidence</div>
        </div>
      </div>
      
      <div class="signal-bar">
        <div class="signal-level" id="signalLevel"></div>
        <div class="threshold-marker" id="thresholdMarker"></div>
      </div>
      
      <div class="visualizers">
        <div>
          <div class="card-title">
            Waveform
            <div class="tone-indicator" id="toneIndicator"></div>
          </div>
          <canvas id="waveformCanvas" height="150"></canvas>
        </div>
        
        <div>
          <div class="card-title">Frequency Spectrum</div>
          <canvas id="spectrumCanvas" height="150"></canvas>
        </div>
      </div>
    </div>

    <div class="status-bar">
      <span id="statusMessage">Ready to decode.</span>
      <span id="timingInfo">Dot: 0ms, Dash: 0ms, Space: 0ms</span>
    </div>
  </div>

  <script>
    console.log('Morse decoder script started loading...');
    
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOMContentLoaded event fired - script is running!');
      
      // DOM Elements
      const startBtn = document.getElementById('startBtn');
      const stopBtn = document.getElementById('stopBtn');
      const clearBtn = document.getElementById('clearBtn');
      const statusDot = document.getElementById('statusDot');
      const waveformCanvas = document.getElementById('waveformCanvas');
      const spectrumCanvas = document.getElementById('spectrumCanvas');
      const outputText = document.getElementById('outputText');
      const morseBuffer = document.getElementById('morseBuffer');
      const currentToneElement = document.getElementById('currentTone');
      const currentWpmElement = document.getElementById('currentWpm');
      const snrElement = document.getElementById('snr');
      const confidenceElement = document.getElementById('confidence');
      const signalLevel = document.getElementById('signalLevel');
      const thresholdMarker = document.getElementById('thresholdMarker');
      const statusMessage = document.getElementById('statusMessage');
      const timingInfo = document.getElementById('timingInfo');
      const toneIndicator = document.getElementById('toneIndicator');

      // QRZ elements
      const qrzUsername = document.getElementById('qrzUsername');
      const qrzPassword = document.getElementById('qrzPassword');
      const qrzTestBtn = document.getElementById('qrzTestBtn');
      const qrzStatusDot = document.getElementById('qrzStatusDot');
      const qrzStatusText = document.getElementById('qrzStatusText');
      const callsignLog = document.getElementById('callsignLog');
      const callsignEntries = document.getElementById('callsignEntries');
      const autoCallsignDetection = document.getElementById('autoCallsignDetection');

      // Input elements
      const toneFrequencyInput = document.getElementById('toneFrequency');
      const toneFrequencyValue = document.getElementById('toneFrequencyValue');
      const wpmRangeInput = document.getElementById('wpmRange');
      const wpmValue = document.getElementById('wpmValue');
      const thresholdLevelInput = document.getElementById('thresholdLevel');
      const thresholdValue = document.getElementById('thresholdValue');
      const noiseReductionInput = document.getElementById('noiseReduction');
      const noiseReductionValue = document.getElementById('noiseReductionValue');

      // Audio processing variables
      let audioContext = null;
      let analyzer = null;
      let stream = null;
      let animationFrame = null;
      let isListening = false;
      
      // Morse decoding variables
      let preferredTone = 700;
      let wpm = 20;
      let thresholdLevel = 0.10;
      let noiseReduction = 5;
      let dotDuration = 1200 / wpm; // milliseconds
      let dashDuration = dotDuration * 3;
      let elementSpaceDuration = dotDuration;
      let letterSpaceDuration = dotDuration * 3;
      let wordSpaceDuration = dotDuration * 7;
      
      let currentMorseSequence = '';
      let lastSignalEndTime = 0;
      let signalStartTime = 0;
      let isSignalOn = false;
      let adaptiveThreshold = thresholdLevel;
      let noiseFloor = 0;
      let peakLevel = 0;
      let snrValue = 0;
      let confidenceValue = 0;
      
      // Arrays to store timing data for adaptive calculations
      let dotLengths = [];
      let dashLengths = [];
      let spaceLengths = [];
      let receivedText = '';

      // QRZ Integration variables
      let qrzSessionKey = null;
      let qrzEnabled = false;
      let callsignCache = new Map();
      let detectedCallsigns = [];
      let currentBubble = null;
      let autoDetectCallsigns = false; // Default to OFF

      // Callsign validation regex (basic ham radio callsign patterns)
      const callsignRegex = /\b[A-Z0-9]{1,3}[0-9][A-Z0-9]{0,3}[A-Z]\b/g;
      
      // Morse code mapping
      const morseCodeMap = {
        '.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E',
        '..-.': 'F', '--.': 'G', '....': 'H', '..': 'I', '.---': 'J',
        '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O',
        '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T',
        '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y',
        '--..': 'Z', '.----': '1', '..---': '2', '...--': '3', '....-': '4',
        '.....': '5', '-....': '6', '--...': '7', '---..': '8', '----.': '9',
        '-----': '0', '--..--': ',', '.-.-.-': '.', '..--..': '?',
        '-..-.': '/', '-.--.': '(', '-.--.-': ')', '.-...': '&',
        '---...': ':', '-.-.-.': ';', '-...-': '=', '.-.-.': '+',
        '-....-': '-', '..--.-': '_', '.-..-.': '"', '...-..-': '$',
        '.--.-.': '@', '.-.-.': '+', '.-.-': 'Ä', '---.': 'Ö', '..--': 'Ü',
        '...-.-': '<SK>', '-.-.-': '<KA>'
      };

      // Canvas setup
      const waveformCtx = waveformCanvas.getContext('2d');
      const spectrumCtx = spectrumCanvas.getContext('2d');

      // Debug: Check if elements are found
      console.log('DOM elements check:');
      console.log('startBtn:', startBtn);
      console.log('qrzTestBtn:', qrzTestBtn);
      console.log('qrzUsername:', qrzUsername);
      console.log('qrzPassword:', qrzPassword);

      // QRZ Integration Functions
      function updateQRZStatus() {
        const hasCredentials = qrzUsername.value.trim() && qrzPassword.value.trim();
        
        if (hasCredentials) {
          qrzStatusText.textContent = 'Credentials entered - test connection';
          saveQRZCredentials();
        } else {
          qrzStatusText.textContent = 'QRZ lookup disabled - enter credentials';
          qrzStatusDot.classList.remove('connected');
          qrzEnabled = false;
          qrzSessionKey = null;
        }
      }

      function saveQRZCredentials() {
        try {
          const credentials = {
            username: qrzUsername.value.trim(),
            password: qrzPassword.value.trim()
          };
          // Store in memory only (not localStorage due to security)
          window.qrzCredentials = credentials;
        } catch (e) {
          console.warn('Could not save QRZ credentials');
        }
      }

      function loadQRZCredentials() {
        try {
          if (window.qrzCredentials) {
            qrzUsername.value = window.qrzCredentials.username || '';
            qrzPassword.value = window.qrzCredentials.password || '';
            updateQRZStatus();
          }
          
          // Load auto-detection preference (default to false)
          if (window.autoDetectPreference !== undefined) {
            autoDetectCallsigns = window.autoDetectPreference;
            autoCallsignDetection.checked = autoDetectCallsigns;
          }
        } catch (e) {
          console.warn('Could not load QRZ credentials or preferences');
        }
      }

      async function testQRZConnection() {
        console.log('QRZ test button clicked');
        if (!qrzUsername.value.trim() || !qrzPassword.value.trim()) {
          qrzStatusText.textContent = 'Please enter both username and password';
          return;
        }

        qrzTestBtn.disabled = true;
        qrzStatusText.textContent = 'Testing connection...';
        
        try {
          const success = await loginToQRZ();
          if (success) {
            qrzEnabled = true;
            qrzStatusDot.classList.add('connected');
            qrzStatusText.textContent = 'QRZ connection successful!';
            
            // Test with a known callsign
            setTimeout(async function() {
              try {
                const testResult = await lookupCallsign('AA7BQ');
                if (testResult) {
                  qrzStatusText.textContent = 'QRZ ready for callsign lookups';
                }
              } catch (e) {
                qrzStatusText.textContent = 'QRZ connected but lookup failed';
              }
            }, 1000);
          } else {
            qrzEnabled = false;
            qrzStatusDot.classList.remove('connected');
            qrzStatusText.textContent = 'QRZ connection failed - check credentials';
          }
        } catch (error) {
          qrzEnabled = false;
          qrzStatusDot.classList.remove('connected');
          qrzStatusText.textContent = 'QRZ error: ' + error.message;
        }
        
        qrzTestBtn.disabled = false;
      }

      async function loginToQRZ() {
        const username = qrzUsername.value.trim();
        const password = qrzPassword.value.trim();
        
        if (!username || !password) return false;

        try {
          const url = 'https://xmldata.qrz.com/xml/current/?username=' + encodeURIComponent(username) + '&password=' + encodeURIComponent(password) + '&agent=MorseDecoder/1.0';
          
          // Note: This will require CORS proxy in production
          const response = await fetch('https://api.allorigins.win/get?url=' + encodeURIComponent(url));
          const data = await response.json();
          
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(data.contents, "text/xml");
          
          const keyElement = xmlDoc.querySelector('Session Key');
          const errorElement = xmlDoc.querySelector('Session Error');
          
          if (errorElement) {
            throw new Error(errorElement.textContent);
          }
          
          if (keyElement) {
            qrzSessionKey = keyElement.textContent;
            return true;
          }
          
          return false;
        } catch (error) {
          console.error('QRZ login error:', error);
          throw error;
        }
      }

      async function lookupCallsign(callsign) {
        if (!qrzEnabled || !qrzSessionKey) return null;
        
        // Check cache first
        if (callsignCache.has(callsign)) {
          return callsignCache.get(callsign);
        }

        try {
          const url = 'https://xmldata.qrz.com/xml/current/?s=' + qrzSessionKey + '&callsign=' + encodeURIComponent(callsign);
          
          // Note: This will require CORS proxy in production
          const response = await fetch('https://api.allorigins.win/get?url=' + encodeURIComponent(url));
          const data = await response.json();
          
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(data.contents, "text/xml");
          
          const errorElement = xmlDoc.querySelector('Session Error');
          if (errorElement) {
            if (errorElement.textContent.includes('Session Timeout')) {
              // Session expired, try to re-login
              const loginSuccess = await loginToQRZ();
              if (loginSuccess) {
                return await lookupCallsign(callsign); // Retry with new session
              }
            }
            throw new Error(errorElement.textContent);
          }
          
          const callElement = xmlDoc.querySelector('Callsign');
          if (!callElement) {
            return null; // Callsign not found
          }
          
          // Parse callsign data
          const callsignData = {
            call: getElementText(callElement, 'call'),
            fname: getElementText(callElement, 'fname'),
            name: getElementText(callElement, 'name'),
            addr1: getElementText(callElement, 'addr1'),
            addr2: getElementText(callElement, 'addr2'),
            state: getElementText(callElement, 'state'),
            zip: getElementText(callElement, 'zip'),
            country: getElementText(callElement, 'country'),
            grid: getElementText(callElement, 'grid'),
            class: getElementText(callElement, 'class'),
            email: getElementText(callElement, 'email'),
            qslmgr: getElementText(callElement, 'qslmgr'),
            eqsl: getElementText(callElement, 'eqsl'),
            lotw: getElementText(callElement, 'lotw'),
            image: getElementText(callElement, 'image'),
            nickname: getElementText(callElement, 'nickname'),
            name_fmt: getElementText(callElement, 'name_fmt')
          };
          
          // Cache the result
          callsignCache.set(callsign, callsignData);
          
          return callsignData;
        } catch (error) {
          console.error('QRZ lookup error:', error);
          return null;
        }
      }

      function getElementText(parent, tagName) {
        const element = parent.querySelector(tagName);
        return element ? element.textContent : '';
      }

      function detectCallsigns(text) {
        const matches = text.match(callsignRegex);
        if (!matches) return [];
        
        // Filter and validate callsigns according to ITU regulations
        const validCallsigns = matches.filter(function(call) {
          return isValidITUCallsign(call);
        });
        
        return validCallsigns.filter(function(value, index, self) {
          return self.indexOf(value) === index; // Remove duplicates
        });
      }

      function isValidITUCallsign(callsign) {
        // Remove any leading/trailing whitespace
        callsign = callsign.trim().toUpperCase();
        
        // Must be between 3-8 characters (typical amateur radio range)
        if (callsign.length < 3 || callsign.length > 8) return false;
        
        // Exclude common false positives that match the basic pattern
        const excludeList = [
          '10M', '20M', '40M', '80M', '160M', '6M', '2M', '70CM',
          'FM', 'AM', 'SSB', 'CW', 'PSK', 'FT8', 'FT4', 'RTTY',
          'USB', 'LSB', 'DIGI', 'APRS', 'DMR', 'D74', 'IC7', 
          '144', '432', '220', '902', '1296', 'VHF', 'UHF', 'SHF'
        ];
        if (excludeList.includes(callsign)) return false;
        
        // ITU amateur radio callsign structure validation
        // Basic pattern: [PREFIX][DIGIT][SUFFIX]
        // PREFIX: 1-2 letters (some regions allow more)
        // DIGIT: single digit (0-9) 
        // SUFFIX: 1-4 letters
        
        // Find the digit position (should have exactly one digit)
        const digitMatches = callsign.match(/\d/g);
        if (!digitMatches || digitMatches.length !== 1) return false;
        
        const digitPos = callsign.indexOf(digitMatches[0]);
        const prefix = callsign.substring(0, digitPos);
        const digit = callsign.charAt(digitPos);
        const suffix = callsign.substring(digitPos + 1);
        
        // Validate prefix (1-3 letters, but typically 1-2)
        if (prefix.length < 1 || prefix.length > 3) return false;
        if (!/^[A-Z]+$/.test(prefix)) return false;
        
        // Validate digit (0-9)
        if (!/^[0-9]$/.test(digit)) return false;
        
        // Validate suffix (1-4 letters)
        if (suffix.length < 1 || suffix.length > 4) return false;
        if (!/^[A-Z]+$/.test(suffix)) return false;
        
        // Additional ITU-specific validations
        
        // Most amateur callsigns start with specific prefix patterns
        // ITU Region 1 (Europe, Africa, Middle East): A-L
        // ITU Region 2 (Americas): K, N, W, AA-AL, KA-KZ, NA-NZ, WA-WZ
        // ITU Region 3 (Asia-Pacific): M-Z (excluding those in Region 2)
        
        const firstLetter = prefix.charAt(0);
        
        // Very loose validation - just exclude obviously invalid prefixes
        // that would never be amateur radio
        const invalidFirstLetters = ['I', 'Q', 'X']; // Generally reserved for other services
        if (invalidFirstLetters.includes(firstLetter)) {
          // Exception: Some regions do use these (like Italian I stations)
          // So we'll be permissive and allow them
        }
        
        // Additional pattern checks for common amateur formats
        
        // US-style calls (W/K/N + digit + 1-3 letters)
        if (/^[WKN][0-9][A-Z]{1,3}$/.test(callsign)) return true;
        
        // US-style extra class (AA-AL, KA-KZ, NA-NZ, WA-WZ + digit + 1-3 letters)
        if (/^[AKNW][A-Z][0-9][A-Z]{1,3}$/.test(callsign)) return true;
        
        // European-style calls (prefix + digit + suffix)
        if (/^[A-L][A-Z]?[0-9][A-Z]{1,4}$/.test(callsign)) return true;
        
        // Asian/Pacific calls 
        if (/^[M-Z][A-Z]?[0-9][A-Z]{1,4}$/.test(callsign)) return true;
        
        // Special event stations and other valid patterns
        if (/^[A-Z]{1,2}[0-9][A-Z]{1,4}$/.test(callsign)) return true;
        
        // If we get here, it might still be valid but not matching common patterns
        // Be conservative and reject
        return false;
      }

      function addDetectedCallsign(callsign) {
        const timestamp = new Date().toLocaleTimeString();
        
        // Add to detected callsigns list
        const existingIndex = detectedCallsigns.findIndex(function(entry) {
          return entry.callsign === callsign;
        });
        
        if (existingIndex >= 0) {
          // Update timestamp for existing callsign
          detectedCallsigns[existingIndex].timestamp = timestamp;
          detectedCallsigns[existingIndex].count++;
        } else {
          // Add new callsign
          detectedCallsigns.unshift({
            callsign: callsign,
            timestamp: timestamp,
            count: 1,
            qrzData: null
          });
          
          // Limit to last 10 callsigns
          if (detectedCallsigns.length > 10) {
            detectedCallsigns.pop();
          }
        }
        
        updateCallsignLog();
        
        // Trigger QRZ lookup if enabled
        if (qrzEnabled) {
          lookupCallsign(callsign).then(function(data) {
            if (data) {
              const entry = detectedCallsigns.find(function(e) {
                return e.callsign === callsign;
              });
              if (entry) {
                entry.qrzData = data;
                updateCallsignLog();
              }
            }
          }).catch(function(err) {
            console.warn('QRZ lookup failed for', callsign, err);
          });
        }
      }

      function updateCallsignLog() {
        if (detectedCallsigns.length === 0) {
          callsignEntries.innerHTML = 'No callsigns detected yet...';
          return;
        }
        
        let entriesHTML = '';
        detectedCallsigns.forEach(function(entry) {
          const qrzStatus = entry.qrzData ? '✓' : (qrzEnabled ? '⏳' : '');
          const countText = entry.count > 1 ? ' (' + entry.count + 'x)' : '';
          
          entriesHTML += '<div class="callsign-entry">' +
            '<span class="callsign">' + entry.callsign + countText + ' ' + qrzStatus + '</span>' +
            '<span class="timestamp">' + entry.timestamp + '</span>' +
            '</div>';
        });
        
        callsignEntries.innerHTML = entriesHTML;
      }

      function wrapCallsignsInText(text) {
        return text.replace(callsignRegex, function(match) {
          return '<span class="detected-callsign" data-callsign="' + match + '">' + match + '</span>';
        });
      }

      function showQRZBubble(callsignElement, callsign) {
        // Remove existing bubble
        hideQRZBubble();
        
        const entry = detectedCallsigns.find(function(e) {
          return e.callsign === callsign;
        });
        const qrzData = entry ? entry.qrzData : null;
        
        // Create bubble
        const bubble = document.createElement('div');
        bubble.className = 'qrz-bubble';
        bubble.innerHTML = createBubbleContent(callsign, qrzData);
        
        // Add to document body first to get dimensions
        document.body.appendChild(bubble);
        currentBubble = bubble;
        
        // Get element and viewport dimensions
        const rect = callsignElement.getBoundingClientRect();
        const bubbleRect = bubble.getBoundingClientRect();
        
        // Calculate position - default below the callsign
        let left = rect.left + (rect.width / 2) - (bubbleRect.width / 2);
        let top = rect.bottom + 10;
        
        // Adjust horizontal position if off-screen
        if (left < 10) {
          left = 10;
        } else if (left + bubbleRect.width > window.innerWidth - 10) {
          left = window.innerWidth - bubbleRect.width - 10;
        }
        
        // Adjust vertical position if off-screen (show above instead)
        if (top + bubbleRect.height > window.innerHeight - 10) {
          top = rect.top - bubbleRect.height - 10;
        }
        
        // Apply final position
        bubble.style.left = left + 'px';
        bubble.style.top = top + 'px';
        
        // Show bubble with animation
        setTimeout(function() {
          bubble.classList.add('show');
        }, 10);
        
        // Create connecting line after positioning
        createConnectingLine(callsignElement, bubble);
        
        // If no QRZ data and QRZ is enabled, trigger lookup
        if (!qrzData && qrzEnabled) {
          lookupCallsign(callsign).then(function(data) {
            if (data && currentBubble === bubble) {
              bubble.innerHTML = createBubbleContent(callsign, data);
              // Update the entry
              if (entry) entry.qrzData = data;
              updateCallsignLog();
            }
          }).catch(function(err) {
            if (currentBubble === bubble) {
              bubble.innerHTML = createBubbleContent(callsign, null, 'Lookup failed');
            }
          });
        }
      }

      function createBubbleContent(callsign, qrzData, error) {
        error = error || null;
        
        if (error) {
          return '<h5>' + callsign + '</h5>' +
                 '<div class="qrz-error">' + error + '</div>';
        }
        
        if (!qrzData) {
          if (qrzEnabled) {
            return '<h5>' + callsign + '</h5>' +
                   '<div class="qrz-loading">Loading QRZ data...</div>';
          } else {
            return '<h5>' + callsign + '</h5>' +
                   '<div class="qrz-field">QRZ lookup disabled</div>' +
                   '<div style="font-size: 10px; margin-top: 8px; color: var(--text-secondary);">' +
                   'Configure QRZ credentials in settings to enable automatic lookups' +
                   '</div>';
          }
        }
        
        const name = qrzData.name_fmt || (qrzData.fname + ' ' + qrzData.name).trim();
        const location = [qrzData.addr2, qrzData.state, qrzData.country].filter(function(x) { return x; }).join(', ');
        
        let content = '<h5>' + qrzData.call + '</h5>';
        
        if (name) {
          content += '<div class="qrz-field"><span class="qrz-label">Name:</span> ' + name + '</div>';
        }
        if (location) {
          content += '<div class="qrz-field"><span class="qrz-label">Location:</span> ' + location + '</div>';
        }
        if (qrzData.grid) {
          content += '<div class="qrz-field"><span class="qrz-label">Grid:</span> ' + qrzData.grid + '</div>';
        }
        if (qrzData.class) {
          content += '<div class="qrz-field"><span class="qrz-label">Class:</span> ' + qrzData.class + '</div>';
        }
        if (qrzData.email) {
          content += '<div class="qrz-field"><span class="qrz-label">Email:</span> ' + qrzData.email + '</div>';
        }
        if (qrzData.qslmgr && qrzData.qslmgr !== 'NONE') {
          content += '<div class="qrz-field"><span class="qrz-label">QSL Mgr:</span> ' + qrzData.qslmgr + '</div>';
        }
        
        content += '<div style="margin-top: 8px; font-size: 10px; color: var(--text-secondary);">';
        if (qrzData.eqsl === 'Y') content += 'eQSL ✓ ';
        if (qrzData.lotw === 'Y') content += 'LoTW ✓ ';
        content += 'Data from QRZ.com</div>';
        
        return content;
      }

      function createConnectingLine(callsignElement, bubble) {
        const line = document.createElement('div');
        line.className = 'connecting-line';
        
        // Get current positions after bubble is positioned
        const callsignRect = callsignElement.getBoundingClientRect();
        const bubbleRect = bubble.getBoundingClientRect();
        
        // Calculate connection points
        const startX = callsignRect.left + (callsignRect.width / 2);
        const startY = callsignRect.bottom;
        const endX = bubbleRect.left + (bubbleRect.width / 2);
        const endY = bubbleRect.top;
        
        // Calculate line properties
        const deltaX = endX - startX;
        const deltaY = endY - startY;
        const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
        
        // Position and style the line
        line.style.left = startX + 'px';
        line.style.top = startY + 'px';
        line.style.width = length + 'px';
        line.style.transform = 'rotate(' + angle + 'deg)';
        line.style.transformOrigin = '0 50%';
        
        // Add line to document
        document.body.appendChild(line);
        bubble.connectingLine = line;
      }

      function hideQRZBubble() {
        if (currentBubble) {
          currentBubble.classList.remove('show');
          if (currentBubble.connectingLine) {
            currentBubble.connectingLine.remove();
          }
          setTimeout(function() {
            if (currentBubble && currentBubble.parentNode) {
              currentBubble.remove();
            }
          }, 200);
          currentBubble = null;
        }
      }

      // Update the display for the tone frequency
      function updateToneFrequency() {
        preferredTone = parseInt(toneFrequencyInput.value, 10);
        toneFrequencyValue.textContent = preferredTone;
        updateTimingValues();
      }

      // Update the display for WPM
      function updateWPM() {
        wpm = parseInt(wpmRangeInput.value, 10);
        wpmValue.textContent = wpm;
        currentWpmElement.textContent = wpm; // Also update the detected WPM display
        
        // Clear timing arrays when manually changing speed
        dotLengths = [];
        dashLengths = [];
        spaceLengths = [];
        
        updateTimingValues();
      }

      // Update timing values based on WPM
      function updateTimingValues() {
        dotDuration = 1200 / wpm; // milliseconds
        dashDuration = dotDuration * 3;
        elementSpaceDuration = dotDuration;
        letterSpaceDuration = dotDuration * 3;
        wordSpaceDuration = dotDuration * 7;
        
        timingInfo.textContent = 'Dot: ' + Math.round(dotDuration) + 'ms, Dash: ' + Math.round(dashDuration) + 'ms, Space: ' + Math.round(letterSpaceDuration) + 'ms';
      }

      // Update the threshold level
      function updateThreshold() {
        thresholdLevel = parseFloat(thresholdLevelInput.value);
        thresholdValue.textContent = thresholdLevel.toFixed(2);
        adaptiveThreshold = thresholdLevel;
        
        // Update the threshold marker
        thresholdMarker.style.left = (thresholdLevel * 100) + '%';
      }

      // Update noise reduction level
      function updateNoiseReduction() {
        noiseReduction = parseInt(noiseReductionInput.value, 10);
        noiseReductionValue.textContent = noiseReduction;
      }

      // Clear the output display
      function clearOutput() {
        outputText.innerHTML = '';
        morseBuffer.textContent = '';
        currentMorseSequence = '';
        detectedCallsigns = [];
        callsignCache.clear();
        updateCallsignLog();
        hideQRZBubble();
      }

      // Start the decoding process
      async function startDecoding() {
        console.log('Start button clicked');
        try {
          // Create audio context
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          
          // Get microphone stream
          stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          
          // Create analyzer with smaller buffer for faster response at high speeds
          const source = audioContext.createMediaStreamSource(stream);
          analyzer = audioContext.createAnalyser();
          analyzer.fftSize = 512; // Reduced from 2048 to improve responsiveness
          analyzer.smoothingTimeConstant = 0.3; // Moderate smoothing
          source.connect(analyzer);
          
          // Update UI
          startBtn.disabled = true;
          stopBtn.disabled = false;
          statusDot.classList.remove('off');
          statusDot.classList.add('on');
          isListening = true;
          statusMessage.textContent = 'Decoding in progress... (Auto-adjusting to signal)';
          
          // Start processing audio
          processAudio();
        } catch (error) {
          console.error('Error accessing microphone:', error);
          statusMessage.textContent = 'Error: ' + error.message;
        }
      }

      // Stop the decoding process
      function stopDecoding() {
        if (animationFrame) {
          cancelAnimationFrame(animationFrame);
          animationFrame = null;
        }
        
        if (stream) {
          stream.getTracks().forEach(function(track) { track.stop(); });
          stream = null;
        }
        
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
        
        // Update UI
        startBtn.disabled = false;
        stopBtn.disabled = true;
        statusDot.classList.remove('on');
        statusDot.classList.add('off');
        isListening = false;
        statusMessage.textContent = 'Decoding stopped.';
      }

      // Implement the Goertzel algorithm for tone detection
      function goertzelDetect(buffer, sampleRate, targetFrequency) {
        const bufferSize = buffer.length;
        const omega = 2.0 * Math.PI * targetFrequency / sampleRate;
        const sine = Math.sin(omega);
        const cosine = Math.cos(omega);
        const coeff = 2.0 * cosine;
        
        let q1 = 0;
        let q2 = 0;
        
        // Use only a portion of the buffer for faster response at high speeds
        const effectiveBufferSize = Math.min(bufferSize, 512);
        const step = Math.floor(bufferSize / effectiveBufferSize) || 1;
        
        for (let i = 0; i < bufferSize; i += step) {
          // Normalize the value from 0-255 to -1 to 1
          const normalized = (buffer[i] / 128.0) - 1.0;
          const q0 = coeff * q1 - q2 + normalized;
          q2 = q1;
          q1 = q0;
        }
        
        const real = q1 - q2 * cosine;
        const imag = q2 * sine;
        
        return Math.sqrt(real*real + imag*imag) / (effectiveBufferSize/2);
      }

      // Process audio data from the microphone
      function processAudio() {
        if (!analyzer || !audioContext) return;
        
        const bufferLength = analyzer.frequencyBinCount;
        const timeData = new Uint8Array(bufferLength);
        const frequencyData = new Uint8Array(bufferLength);
        
        analyzer.getByteTimeDomainData(timeData);
        analyzer.getByteFrequencyData(frequencyData);
        
        // Draw waveform
        drawWaveform(timeData);
        
        // Draw frequency spectrum
        drawSpectrum(frequencyData);
        
        // Find the dominant frequency using Goertzel across a wider range
        const sampleRate = audioContext.sampleRate;
        
        // Calculate signal strength across the full 500-900 Hz range
        let maxStrength = 0;
        let dominantFrequency = 0;
        
        // Use Goertzel to scan the entire 500-900 Hz range
        for (let freq = 500; freq <= 900; freq += 20) {  // Step by 20Hz for faster scanning
          const strength = goertzelDetect(timeData, sampleRate, freq);
          if (strength > maxStrength) {
            maxStrength = strength;
            dominantFrequency = freq;
          }
        }
        
        // Also check for noise outside the target range
        let noiseStrength = 0;
        for (let freq = 300; freq < 1200; freq += 150) {  // Larger steps for noise checking
          if (freq < 500 || freq > 900) {
            noiseStrength = Math.max(noiseStrength, goertzelDetect(timeData, sampleRate, freq));
          }
        }
        
        // Update noise floor and peak values with smoothing
        noiseFloor = noiseFloor * 0.95 + noiseStrength * 0.05;
        peakLevel = Math.max(peakLevel * 0.95, maxStrength);
        
        // Calculate SNR
        snrValue = noiseFloor > 0 ? maxStrength / noiseFloor : 0;
        snrElement.textContent = snrValue.toFixed(1);
        
        // Apply adaptive threshold based on signal to noise ratio
        adaptiveThreshold = Math.max(thresholdLevel, noiseFloor * (2 + noiseReduction * 0.5));
        
        // Calculate confidence
        confidenceValue = Math.min(100, Math.round((snrValue / 5) * 100));
        confidenceElement.textContent = confidenceValue + '%';
        
        // Update UI with current tone
        currentToneElement.textContent = Math.round(dominantFrequency);
        
        // Auto-adjust preferred tone if consistently detecting a different frequency
        if (dominantFrequency > 0 && maxStrength > adaptiveThreshold * 2) {
          // Slowly adjust the preferred tone toward the detected tone
          preferredTone = preferredTone * 0.95 + dominantFrequency * 0.05;
          // Ensure it stays within 500-900 Hz range
          preferredTone = Math.max(500, Math.min(900, preferredTone));
          // Update the slider and display
          toneFrequencyInput.value = Math.round(preferredTone);
          toneFrequencyValue.textContent = Math.round(preferredTone);
        }
        
        // Update signal level visualization
        const levelPercentage = (maxStrength / (adaptiveThreshold * 2)) * 100;
        signalLevel.style.width = Math.min(100, levelPercentage) + '%';
        
        // Tone match indicator
        if (maxStrength > adaptiveThreshold) {
          toneIndicator.classList.add('tone-match');
        } else {
          toneIndicator.classList.remove('tone-match');
        }
        
        // Morse code detection logic
        const now = Date.now();
        
        // Keep track of signal durations and spaces for WPM calculation
        let wordSpaceDetected = false;
        
        // Detect signal state change
        if (maxStrength > adaptiveThreshold && !isSignalOn) {
          // Signal just turned on
          isSignalOn = true;
          signalStartTime = now;
          
          // Check if this is a new character or word
          const silenceDuration = now - lastSignalEndTime;
          
          if (lastSignalEndTime > 0) {
            // Store space duration for adaptive timing
            if (silenceDuration > 10) {  // Ignore very short transitions
              spaceLengths.push(silenceDuration);
            }
            
            // Handle character and word spaces
            if (silenceDuration > letterSpaceDuration * 0.75 && 
                silenceDuration < wordSpaceDuration * 0.75 && 
                currentMorseSequence.length > 0) {
              // End of a character
              decodeMorse(currentMorseSequence);
              currentMorseSequence = '';
            } else if (silenceDuration >= wordSpaceDuration * 0.75) {
              // End of a word - add space if needed
              if (currentMorseSequence.length > 0) {
                decodeMorse(currentMorseSequence);
                currentMorseSequence = '';
              }
              // Add space between words
              outputText.innerHTML += ' ';
              wordSpaceDetected = true;
              
              // Handle callsign detection after word completion
              handleWordSpace();
            }
          }
        } else if (maxStrength <= adaptiveThreshold && isSignalOn) {
          // Signal just turned off
          isSignalOn = false;
          const signalDuration = now - signalStartTime;
          lastSignalEndTime = now;
          
          // Only process signals longer than noise threshold
          if (signalDuration > 10) {  // Ignore very short transitions
            // Store signal duration for adaptive timing and determine if dot or dash
            if (signalDuration < dashDuration * 0.6) {
              dotLengths.push(signalDuration);
              currentMorseSequence += '.';
              
              // Immediate WPM calculation from each dot
              // This ensures immediate feedback on speed changes
              const detectedWpm = Math.round(1200 / signalDuration);
              if (detectedWpm >= 12 && detectedWpm <= 40) {
                // Update display immediately
                currentWpmElement.textContent = detectedWpm;
                
                // Update actual WPM value with smoothing to avoid jumpiness
                wpm = Math.round(wpm * 0.7 + detectedWpm * 0.3);
                wpmRangeInput.value = wpm;
                wpmValue.textContent = wpm;
                
                // Update timing values
                updateTimingValues();
              }
            } else {
              dashLengths.push(signalDuration);
              currentMorseSequence += '-';
            }
            
            // Update morse buffer display
            morseBuffer.textContent = currentMorseSequence;
          }
        }
        
        // Handle extended silence - adds reliability for last character
        if (!isSignalOn && lastSignalEndTime > 0 && (now - lastSignalEndTime) > letterSpaceDuration * 1.2) {
          // End current character if there is one
          if (currentMorseSequence.length > 0) {
            decodeMorse(currentMorseSequence);
            currentMorseSequence = '';
            
            // Check for word space after additional time
            if ((now - lastSignalEndTime) > wordSpaceDuration && !wordSpaceDetected) {
              outputText.innerHTML += ' ';
              wordSpaceDetected = true;
              
              // Handle callsign detection after word completion
              handleWordSpace();
            }
          }
        }
        
        // Limit buffer sizes to avoid lag
        if (dotLengths.length > 5) dotLengths.splice(0, dotLengths.length - 5);
        if (dashLengths.length > 5) dashLengths.splice(0, dashLengths.length - 5);
        if (spaceLengths.length > 5) spaceLengths.splice(0, spaceLengths.length - 5);
        
        // Continue the processing loop
        animationFrame = requestAnimationFrame(processAudio);
      }

      // Draw the waveform on canvas
      function drawWaveform(timeData) {
        const width = waveformCanvas.width;
        const height = waveformCanvas.height;
        
        waveformCtx.clearRect(0, 0, width, height);
        waveformCtx.lineWidth = 2;
        waveformCtx.strokeStyle = '#1a73e8';
        waveformCtx.beginPath();
        
        const sliceWidth = width / timeData.length;
        let x = 0;
        
        for (let i = 0; i < timeData.length; i++) {
          const v = timeData[i] / 128.0;
          const y = v * height / 2;
          
          if (i === 0) {
            waveformCtx.moveTo(x, y);
          } else {
            waveformCtx.lineTo(x, y);
          }
          
          x += sliceWidth;
        }
        
        waveformCtx.stroke();
        
        // Draw threshold line
        waveformCtx.beginPath();
        waveformCtx.strokeStyle = '#ea4335';
        waveformCtx.setLineDash([5, 5]);
        const thresholdY = (128 * (1 + adaptiveThreshold)) / 128.0 * height / 2;
        waveformCtx.moveTo(0, thresholdY);
        waveformCtx.lineTo(width, thresholdY);
        waveformCtx.stroke();
        waveformCtx.setLineDash([]);
      }

      // Draw the frequency spectrum on canvas
      function drawSpectrum(frequencyData) {
        const width = spectrumCanvas.width;
        const height = spectrumCanvas.height;
        
        spectrumCtx.clearRect(0, 0, width, height);
        
        // Plot only the relevant part of the spectrum (400-1000 Hz)
        const minFreq = 400;
        const maxFreq = 1000;
        const sampleRate = audioContext ? audioContext.sampleRate : 44100;
        const minBin = Math.floor(minFreq * frequencyData.length / (sampleRate / 2));
        const maxBin = Math.ceil(maxFreq * frequencyData.length / (sampleRate / 2));
        const binCount = maxBin - minBin;
        
        // Skip some bins for faster rendering
        const skipFactor = Math.ceil(binCount / 100) || 1;
        const barWidth = width / (binCount / skipFactor);
        const multiplier = height / 255;
        
        for (let i = 0; i < binCount; i += skipFactor) {
          const binFreq = minFreq + (i / binCount) * (maxFreq - minFreq);
          const barHeight = frequencyData[minBin + i] * multiplier;
          const x = (i / skipFactor) * barWidth;
          const y = height - barHeight;
          
          // Highlight the target frequency range
          if (binFreq >= preferredTone - 30 && binFreq <= preferredTone + 30) {
            spectrumCtx.fillStyle = '#ea4335';
          } else {
            spectrumCtx.fillStyle = '#34a853';
          }
          
          spectrumCtx.fillRect(x, y, barWidth - 1, barHeight);
        }
        
        // Draw preferred tone marker
        const preferredX = ((preferredTone - minFreq) / (maxFreq - minFreq)) * width;
        spectrumCtx.strokeStyle = '#1a73e8';
        spectrumCtx.lineWidth = 2;
        spectrumCtx.beginPath();
        spectrumCtx.moveTo(preferredX, 0);
        spectrumCtx.lineTo(preferredX, height);
        spectrumCtx.stroke();
      }

      // Decode Morse code sequence to text
      function decodeMorse(sequence) {
        if (sequence.length === 0) return;
        
        const character = morseCodeMap[sequence] || '?';
        
        // Add character to output
        const currentText = outputText.innerHTML;
        outputText.innerHTML = currentText + character;
        receivedText += character;
        
        //console.log('Received:', receivedText);
        if (receivedText.length >= 50) {
          receivedText = receivedText.slice(-25); // Keep last 25 characters
        }

        // Check for 'TTT' or 'EEE' in the last three characters
        if (receivedText.length >= 3) {
          const lastThree = receivedText.slice(-3);
          if (lastThree === 'TTT' || lastThree === 'EEE') {
            dotDuration = 1200 / 20; // milliseconds
            receivedText = '';   
          }
        }

        // Auto-scroll to bottom
        outputText.scrollTop = outputText.scrollHeight;
        
        // Flash the character briefly to provide visual feedback
        outputText.classList.add('flash');
        setTimeout(function() {
          outputText.classList.remove('flash');
        }, 100);
      }

      // Handle word spaces and callsign detection
      function handleWordSpace() {
        // Only detect callsigns if auto-detection is enabled
        if (!autoDetectCallsigns) return;
        
        // Check for callsigns in the recent text only when a word is complete
        const plainText = outputText.textContent || '';
        const words = plainText.split(' ');
        const lastWord = words[words.length - 2]; // Get the word before the space
        
        if (lastWord && lastWord.length > 2) {
          const newCallsigns = detectCallsigns(lastWord);
          
          // Add any new callsigns found
          newCallsigns.forEach(function(callsign) {
            const existingCallsign = detectedCallsigns.some(function(entry) {
              return entry.callsign === callsign;
            });
            
            if (!existingCallsign) {
              addDetectedCallsign(callsign);
              
              // Now update the display with highlighting for the complete word
              setTimeout(function() {
                updateCallsignHighlighting();
              }, 100);
            }
          });
        }
      }

      // Update callsign highlighting in the output
      function updateCallsignHighlighting() {
        // Only highlight if auto-detection is enabled
        if (!autoDetectCallsigns) return;
        
        const plainText = outputText.textContent || '';
        const highlightedText = wrapCallsignsInText(plainText);
        
        if (highlightedText !== plainText) {
          outputText.innerHTML = highlightedText;
        }
      }

      // Toggle auto-detection on/off
      function toggleAutoDetection() {
        autoDetectCallsigns = autoCallsignDetection.checked;
        
        if (!autoDetectCallsigns) {
          // Clear all current callsign highlighting and detections
          const plainText = outputText.textContent || '';
          outputText.innerHTML = plainText;
          detectedCallsigns = [];
          updateCallsignLog();
          hideQRZBubble();
        } else {
          // Re-scan the current text for callsigns
          const plainText = outputText.textContent || '';
          if (plainText) {
            const words = plainText.split(' ');
            words.forEach(function(word) {
              if (word.length > 2) {
                const callsigns = detectCallsigns(word);
                callsigns.forEach(function(callsign) {
                  const existingCallsign = detectedCallsigns.some(function(entry) {
                    return entry.callsign === callsign;
                  });
                  
                  if (!existingCallsign) {
                    addDetectedCallsign(callsign);
                  }
                });
              }
            });
            updateCallsignHighlighting();
          }
        }
        
        // Save preference
        try {
          window.autoDetectPreference = autoDetectCallsigns;
        } catch (e) {
          console.warn('Could not save auto-detect preference');
        }
      }

      // Load saved QRZ credentials
      loadQRZCredentials();

      // Initialize settings display
      updateToneFrequency();
      updateWPM();
      updateThreshold();
      updateNoiseReduction();
      updateQRZStatus();
      
      // Set recommended default threshold
      thresholdLevelInput.value = 0.10;
      thresholdLevel = 0.10;
      adaptiveThreshold = 0.10;
      thresholdValue.textContent = "0.10";

      // Event listeners for controls
      if (startBtn) {
        startBtn.addEventListener('click', startDecoding);
        console.log('Start button event listener added');
      } else {
        console.error('Start button not found!');
      }
      
      if (stopBtn) {
        stopBtn.addEventListener('click', stopDecoding);
      } else {
        console.error('Stop button not found!');
      }
      
      if (clearBtn) {
        clearBtn.addEventListener('click', clearOutput);
      } else {
        console.error('Clear button not found!');
      }
      
      if (qrzTestBtn) {
        qrzTestBtn.addEventListener('click', testQRZConnection);
        console.log('QRZ test button event listener added');
      } else {
        console.error('QRZ test button not found!');
      }

      // Event listeners for settings
      toneFrequencyInput.addEventListener('input', updateToneFrequency);
      wpmRangeInput.addEventListener('input', updateWPM);
      thresholdLevelInput.addEventListener('input', updateThreshold);
      noiseReductionInput.addEventListener('input', updateNoiseReduction);

      // QRZ credential listeners
      qrzUsername.addEventListener('input', updateQRZStatus);
      qrzPassword.addEventListener('input', updateQRZStatus);
      
      // Auto-detection toggle listener
      autoCallsignDetection.addEventListener('change', toggleAutoDetection);

      // Add click handlers for callsigns in output
      outputText.addEventListener('click', function(e) {
        console.log('Output clicked, target:', e.target);
        console.log('Target classes:', e.target.className);
        console.log('Has detected-callsign class:', e.target.classList.contains('detected-callsign'));
        
        if (e.target.classList.contains('detected-callsign')) {
          const callsign = e.target.dataset.callsign;
          console.log('Callsign clicked:', callsign);
          
          if (currentBubble && currentBubble.textContent.includes(callsign)) {
            console.log('Hiding existing bubble');
            hideQRZBubble();
          } else {
            console.log('Showing bubble for', callsign);
            showQRZBubble(e.target, callsign);
          }
        } else {
          console.log('Non-callsign clicked, hiding bubble');
          hideQRZBubble();
        }
      });

      // Hide bubble when clicking elsewhere
      document.addEventListener('click', function(e) {
        if (!e.target.closest('.detected-callsign') && !e.target.closest('.qrz-bubble')) {
          hideQRZBubble();
        }
      });

      // Resize canvas elements when window resizes
      function resizeCanvases() {
        // Set canvas dimensions to match their display size
        waveformCanvas.width = waveformCanvas.clientWidth;
        waveformCanvas.height = waveformCanvas.clientHeight;
        spectrumCanvas.width = spectrumCanvas.clientWidth;
        spectrumCanvas.height = spectrumCanvas.clientHeight;
      }

      // Initial resize and add window resize listener
      resizeCanvases();
      window.addEventListener('resize', resizeCanvases);

      // Add keyboard shortcuts
      document.addEventListener('keydown', function(e) {
        // Space bar to start/stop
        if (e.code === 'Space' && !e.repeat) {
          e.preventDefault();
          if (isListening) {
            stopBtn.click();
          } else {
            startBtn.click();
          }
        }
        // 'C' key to clear output
        else if (e.code === 'KeyC' && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          clearBtn.click();
        }
      });

      // Add a function to detect interruptions in audio stream
      function detectAudioStreamInterruption() {
        if (isListening && audioContext && audioContext.state !== 'running') {
          statusMessage.textContent = 'Audio context interrupted. Attempting to resume...';
          audioContext.resume().then(function() {
            statusMessage.textContent = 'Decoding resumed.';
          }).catch(function(err) {
            statusMessage.textContent = 'Error resuming audio: ' + err.message;
            stopDecoding();
          });
        }
      }

      // Check for audio interruptions periodically
      setInterval(detectAudioStreamInterruption, 2000);
      
      // Display initial status message
      statusMessage.textContent = 'Ready to decode. Press Start or spacebar to begin. Auto-callsign detection is OFF by default.';
    });
  </script>
</body>
</html>